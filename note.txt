#include <unistd.h>

int pipe(int filedes[2]);

pipe 를 이용하면 2개의 파일 지시자를 생성할수 있다.
2개가 생성되는 이유는 읽기전용과 쓰기전용의 파이프를 생성하기 위함이다.
filedes[0] 은 읽기 전용, filedes[1] 은 쓰기전용의 파이프로 사용된다.

이들 파이프는 주로 부모프로세스와 자식프로세스간의 통신을 위한 목적으로 사용된다.

성공할경우 0을 실패했을경우에는 -1을 반환하며, 적당한 errno 값을 설정한다.


#include <unistd.h>

pid_t fork(void);

fork는 자식프로세스를 만들기 위해서 사용되는 프로세스 생성기이다.
fork 에 의해 생성된 자식 프로세스는 자신만의 PID 를가지게 되며,
PPID는 부모프로세스의 PID를 가지게 된다.
그밖에 PGID, SID 를 상속받으며, 파일지시자, 시그널등을 상속받는다.
단 파일잠금(lock)와 시그널 팬딩은 상속받지 않는다.

성공할경우 자식 프로세스의 PID가 부모에게 리턴되며, 자식에게는 0이 리턴된다.
실패할경우에는 -1 이 리턴되며, 적절한 errno 값이 설정된다.



#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);

주로 fork() 를 이용해서 자식 프로세스(:12)를 생성했을때 사용한다.
wait() 를 쓰면 자식프로세스가 종료할때까지 해당영역에서 부모프로세스가 sleep() 모드로 기다리게 된다.
이는 자식프로세스와 부모프로세스의 동기화를 위한 목적으로 부모프로세스가 자식프로세스보다 먼저 종료되어서
자식프로세스가 고아 프로세스(PPID 가 1)인 프로세스가 되는걸 방지하기 위한 목적이다.

만약 자식 프로세스가 종료되었다면 함수는 즉시 리턴되며, 자식이 사용한 모든 시스템자원을 해제한다.

그런데 어떤 이유로 부모가 wait()를 호출하기 전에 자식 프로세스가 종료버리는 경우도 있다(잘못된 메모리 연산등으로 인한 죽음, 혹은 정상적으로),
이럴경우 자식프로세스는 좀비(:12)프로세스가 되는데, wait()함수는 즉시 리턴하도록 되어있다.

wait()의 인자 status 를 통하여 자식 프로세스의 상태를 받아올수 있는데,
자식프로세스의 상태값은 자식프로세스의 종료값 * 256(FF) 이다.

종료된 자식의 프로세스 ID는 에러일경우 -1 그렇지 않을경우 0을 반환한다.



 #include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);


fork는 실행되는 순간 부모와 자식으로 나뉜다. 동시에 진행되기 때문에 부모 프로세스가 먼저 종료 될 수도 있다. 이를 막기위해 wait, waitpid 등의 함수를 사용한다.

- 리눅스 리다이렉션 '>'와 '>>'의 차이점 -
'>' : "명령어 > 파일" 일때 파일에 내용을 덮어쓴다.
'>>' : "명령어 >> 파일" 일때 파일의 끝에 내용을 추가한다.

- '>>' 란? -
'>>' : https://mug896.github.io/bash-shell/here_document.html 참조
